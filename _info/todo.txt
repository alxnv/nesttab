imageupload, fileupload - выходить из всех запросов без сохранения сессии
 (abort();    echo json_decode(...),exit)
   - чтобы не затиралась сессия редактирования записи в некоторых случаях
----
индексная таблица записей бд (yy_search) - сделать удаление всех индексных записей подтаблиц данной таблицы типа 'one',
  если изменяется в текущей записи поле, участвующее в урлах подтаблиц (в содержимом вряд ли) -
    чтобы не было битых ссылок в yy_search
-----
!!! в следующих версиях или в этой????
 сделать возможность перехода в редактирование таблицы не из корневой таблицы для этой таблицы, а из другой корневой (или вложенной
  в таблицу вида one верхнего уровня), на которую есть ссылка в таблице
  при этом указывается дополнительный параметр для режимов редактирования, как всей таблицы, так и элемента таблицы и нового элемента
  (дополнительное поле типа id в конце Url)
  в хлебных крошках первым элементом тоже отображается эта (другая корневая) таблица
  - сделать возможность задавать эту подтаблицу для "другой корневой" в случае, если есть соответствующие индексы
-----
in later versions maybe:
 вывод форматированной ошибки (или пустой вывод) в случае, если breadcrumbsEdit - запрос к БД вернул ошибку
----
in later versions:
 при сохранении данных в TableModel в случае ошибки сохранять данные редактирования ($_POST) в элементе сессии вида 
   ['dataXXXX'][$table_id][$rec_id] -> post, а не ['dataXXXX'] -> post, и в случае если была ошибка то отображать данные только для
     данной таблицы и записи, а для других брать дефолтные значения для данной таблицы, и делать session()->forget('dataXXXX') в любом случае
----
для поля типа "Выбор записи" (select) сделать возможность выбора дефолтного значения
-----
ListTableModel->beforeDelete Обработчик
---
сделать возможность foreign keys в таблицах mysql
 для этого сделать onBeforeDelete (там проверять связанные таблицы если нет foreign keys) и 
   onDeleteErrorMessage (там иметь возможность модифицировать сообщение об ошибке удаления)
   !! сначала удалять ключевую запись, а потом удалять из таблицы search (а не наоборот)
---
при редактировании записи бд (виртуальной таблицы) предусмотреть возможность изменения структуры таблицы во время
 редактирования, для этого читать данные по умолчанию при редактировании и сохранении (при этом не перегружать
 память, поставить признак $column[$i]->was_updated = 1 для тех полей, которые редактировались, если кроме них
 есть еще поля, то для них прочитать дефолтные значения)
---
в vue.js закомментировать выдачу в консоль сообщения о development version
---
таблица yy_search - primary key 'url' text протестировать replace with
---
json_decode - error handling (например, когда запорото значение в бд) (возвращает Null если была ошибка)
---
сделать проверку на ошибку при физическом добавлении-изменении поля в таблице, и при ошибке корректировать
  yy_columns
---
UploadFileController, UploadImageController - добавить проверку на валидные расширения файлов при загрузке
  временного файла
---
yy_columns - добавить поле admins_only (bool) - reserved (это поле могут видеть и редактировать только админы)
---
EditController->delete() :
     delete table record (how is this function for 'one' table type?)

---
возможно можно указать максимальную версию до которой можно проапгрейдить текущий nesttab (в composer.lock или 
  еще где нибудь, в проекте)
---
yy_tables - Добавить поле txt_ref - адрес текстового файла для компонентов
  если он указан, то админ может редактировать переменные из этого файла
   поля могут быть 3-х типов : 
   1. integer (если значение без кавычек)
   2. string (если значение в кавычках)
   3. tbl_ref (если переменная имеет название вида *_tbl) - имя таблицы для ссылки
---
!!! uploadTokens - при временной загрузке файлов проверять на неправильные расширения (*.py и т.д.) или (нет) добавлять к имени ".$"
     проверить работу при длинном имени файла (255 символов +-)
  - сделать проверку на read only и "нет места"
  - найти как возвращать сообщение об ошибке (read only и "нет места") в filepond
---
uploadFiles (Загрузка файлов в каталог upload): посмотреть как будет работать при конкурентных запросах
 (несколько threads) - tests, предусмотреть ситуацию, когда нет созданных каталогов каких-то до указанных в counter
 - вести массив номеров каталогов, которые уже просмотрены, и в них не искать больше
 - сделать обработку ошибки при перемещении временно загруженного файла на конечное место
 - сделать проверку на ошибки типа read only и "нет места"
---
docs:
  добавить инфо про поля типа order (только в таблицах типа list, возможно только одно поле на таблицу)
     (в принципе, это подвид типа поля int, хотя писать об этом не нужно), отдельное значение типа поля в yy_columns
	   размерность в байтах поля типа order равна id_size_bytes таблицы в которой это поле
   - поле типа tree (поле ссылается на значение самого этого поля)	 
	   размерность в байтах поля типа tree равна id_size_bytes таблицы в которой это поле
   yy_tables - добавить поле main_ref_id (id колонки, которая является main table_ref для этой таблицы)
   в yy_columns добавить поле can_be_empty (оно соответствует галочке "Требуемое", а также политике deletePolicy
     полей типа table_ref). Перенести в это поле yy_columns->parameters['req' => 1]
-----	 
   написать	функцию getParams(array $arr) 
   @return array (значение поля массива $arr['parameters'] преобразованное из json формата, 
      это значение также заносится в поле 'params' массива, и если оно там уже есть, то берется прямо оттуда,
	  а не перекодируется json)
----
BasicTableModel->getPossibleFieldsToViewAsTable()
----
скорее всего, придется часто загружать в память всю таблицу yy_tables и yy_columns
   можно проверить, сколько времени занимает загрузка подобного объема данных
----
поля типа select переименовать в table_ref
таблицы типа ord переименовать в base
----
для полей типа table_ref сделать возможности ссылки на таблицу любого уровня вложенности и любого типа
  (при создании поля загружается полный список таблиц). Также при создании такого поля в случае ошибки и возврата
  на вью редактирования проверить все ли значения которые были заданы на форме отображаются
-----
для полей типа table_ref при редактировании значения рядом с селектом выводить кнопку "Перейти" (Goto).
 при нажатии на нее открывается страница редактирования записи таблицы на которую ссылаются, выбранной в селекте на текущий момент(в новом окне). (если выбрана пустая запись, то кнопка disabled)
 также сделать редирект для one->edit_rec на one->edit (moved permanently)
----
-----
13.10.23 ночь

1)имена полей типа table_ref по умолчанию предлагать вида <tableNamePart>_id где tableNamePart - это имя таблицы, на которую ссылаемся, без префиксов вида yz_, XX_
 если имя занято, можно предлагать user_id2 и т.д.
2) сделать возможность создания специального поля типа table_ref - user_id (user_ref). Это поле содержит идентификатор пользователя из таблицы users проекта laravel breeze.
 возможно, можно будет добавить метаинформацию таблицы users в nesttab, сделать возможность его редактирования штатными средствами nesttab.
in future: 3) сделать возможность сортировки и фильтрации таблицы содержимого L,D по полям parent_id+table_ref fields
для данной таблицы. (edit/ L,D)
2.1) для тех таблиц, где задано (main)user_id сделать кроме режима фильтрации данных по ид пользователя, галочку "показывать записи всех пользователей", если права текущего пользователя это позволяют. для остальных выводить данные
с фильтром user_id = <id текущего залогиненного пользователя>.

- в принципе, в теории, абстрактно, поле ordr в L соответствует набору столбцов parent_id+table_ref fields, но для
других наборов его задавать смысла нет, если кому-то нужно такое поле, сделают его на хранимых процедурах
4) создание и ведение набора полей id1, ..., idN в текущей версии не делать, и убрать из документации
in future - можно предусмотреть галочку при создании таблицы "создавать поля id1, ..., idN". для их заполнения при добавлении новой записи делать запрос id всех родителей данной таблицы до 0-го уровня
5) license.shtml - добавить jt-sage
6) в документации для поля типа image - написать о функции возвращения <img src,width,height> для заданого значения (из поля записи) по метаинформации из поля типа image с возможностью создания изображения на лету из основного, если оно не существует
-----
-----
in future:
 сделать возможность управления индексами для БД в Nesttab (создается метаструктура для них в Nesttab)
   пока непонятно, хранить метаинформацию в отдельных таблицах БД, либо все хранить в поле parameters yy_tables
    (возможно, вынести информацию из yy_ref(is_table == 1) тоже в yy_tables->parameters
 сделать возможноcть сортировки вывода и фильтрации столбцов таблиц edit/ для L,D (с использованием логики задействования (main)user_id если есть это поле)
----
in future:
 есть задумки по реализации системы версий набора БД (upload/.nesttab_settings, в котором по ключам <config('app.db_host_string')> хранить номер текущей версии набора БД)
----
is_table = 1 проверить на надежность систему присвоения struct-table-settings
----
сделать возможность выбора столбцов id, ord (системных) в наборе столбцов для вывода поля типа 'select'
----
При создании дочерней таблицы в Nesttab не предоставлять возможность выбора из размеров в байтах поля id меньших,
 чем у родительской таблицы.
---
в следующих версяих:
	можно задать для mysql признак addForeignKeys, чтобы при создании структуры таблицы создавались внешние ключи
	также внешние ключи можно задавать для полей типа 'select' (? но как тогда обрабатывать удаление записей
	  на которые указывает значение поля 'select', приведшее к нарушению ключа - хотя можно просто удалять все
	   пока не встретится ошибка)
----
+ !!!! размер поля select должен равняться размеру id таблицы на которую он ссылается

+ сделать поле типа select (при создании и редактировании сделать как для image таблицы через vue)
 при удалении записей на которые указывает это поле, автоматически это не проверяется, можно пользователю 
   проверять через хук onBeforeDelete
----
для L,D написать функцию определения текущей страницы (в общем случае, она просто передается из страницы списка 
    записей)
  (select count(*) limit 1 возвращает 25 или любое число а не 1)
+  для L, D для таблицы поставить признак "вычислять текущую страницу (может нагружать сервер и занимать время
    для большой таблицы)"
----
при удалении поля проверять на наличие в списке select полей ссылок (yy_ref, is_table = 0, выдавать ошибку если найдено) 
 и в колонках вывода списка для L, D (yy_ref, is_table = 1 (в этом случае удалять из yy_ref))
----
+ переименовать yy_select в yy_ref
+ field is_table(bool)
 столбцы на которые ссылаются поля ref - тоже добавлять в эту таблицу,
   так же как и данные полей типа select и список полей для вывода в таблице в L,D
сделать поле типа ref - для транслитерации строк (str)
  yy_columns - добавить поле ref_column - проверять это поле при попытке удаления столбца таблицы
----
+ поставить поле для таблиц "отображать вместе с родителем"  (не исп. пока что)
+ а таже поле "видно только админу" (не исп. пока что)
в следующих версиях - сделать возможность отображения list, ord вместе с родительским элементом
-----
struct-add-table - сделать универсальной в том числе для добавления подтаблиц
  сделать отображение сообщения об ошибке на той же странице, а в случае успеха переход
    на редактирование этой таблицы
----
in some future version:
  сделать программный интерефейс добавления(удаления) записей в nesttab
   добавление записей - передавать в функцию массив, аналог $r
     в этом массиве для полей типа 'file', 'image' - указывать ссылки на файлы которые нужно загрузить в систему
-----
в след. версиях:
  L,D edit - filter над заголовком поля в списке
----
! сделать tree(cat) тип таблиц
(пользователь может выбирать, что использовать в своем проекте, либо tree(если не только у максимального уровня 
вложенности есть данные), либо вложенные list
----
list/editrec - move, delete
------
edit, editrec - id parent_id а не parent_table
----
!!!!! таблицы типа one могут быть вложены в таблицы типа one только верхнего уровня
----
удалять текущий элемент + весь следующий уровень
----
+ вроде сделал проверку для O,L
/*частично в этой версии:
возможная редкая ошибка, но нужно предусмотреть:
  сделать в случае ошибки  из за несоотсветствия метаструктуры бд и физической структуры
   сделать обработку и вывод ошибок:
   - в функции получения текущей записи
   - в функциях связанных с полями типа 'select'
   - при выводе таблицы с содержимым в L,D (из-за 'select' и полей на которые указывает список выводимых
      полей таблицы)
  можно проверить реализацию сохранения полей типа 'select' ('lock tables') и произвольных полей и таблиц    
    метаструктуры БД	  
	*/
----
сделать вью hierarhical-table-list вызываемое из struct-list-tables
  в нем в <ul> выводить в виде дерева список всех таблиц проекта из yy_tables
-----
in future versions:
   предумотреть случай бесконечного зацикливания при работе со структурами (например, yy_tables, yy_columns),
     если они вдруг оказались самозамкнутыми (проверять каждый новый node к которому обращаешься, и в случае
	   повторения node выдавать ошибку)
-----
в будущих версиях:
  сделать repair db 'artisan job', проверяющий и исправляющий соответствие метаструктуры данных и физической структуры
-----
в будущих версиях:
  подумать о файловых полях например поле типа 'fileref', которое работает с файлом '$path . $id_записи',
   где $path задается при создании поля
      - также подумать о поле которое работает с каким то каталогом на основе содержащихся в нем файлов 
----
howto:
  как делать проверку на наличие данных в дочерних таблицах уровня +2 относительно текущего (делаем эту проверку
  перед удалением всех подэлементов уровня +1 от текущего элемента, и текущего элемента)
   для этого для каждой подтаблицы +1 уровня: 
!!! можно склеить все запросы к таблицам!!!
наподобие (SELECT id FROM `yz_list126` limit 1)
 union all (select id from yz_list126 limit 2);
 
 1) получаем все id всех записей таблиц уровня +1 (до некоторого лимита)
 2)    получаем массив $arr = [[<id таблицы>, [id, id]]]
 3)  получаем массив всех подтаблиц уровня + 2 $arSub = [<id_tablelvlPlus1> => [id, ... /* id подтаблицы */]]
 4)    select #id1lvl as id1lvl, #id2lvl as id2lvl from <table_2lvl> where parent_id in ($arr[1]) limit 1
          n раз ( union all select ... )
 5)   в результате будут получены строки вида  id1lvl, id2lvl для таблиц, у которых есть значения в таблице id2lvl для всего набора ids
 6) повторяем пункт 1 пока не кончатся записи в таблица уровня +1 c lvl1.parent_id == lvl0.id, где lvl0.id - 
      id текущей записи
   
/* это не нужно
   1) получаем список всех id (до какого-то лимита)  - $ids = [id, ...]
   2)   для каждой подтаблицы уровня +1+1
   2) делаем select <n> as num from <table_name> where parent_id in $ids limit 1
   3) если получен хотя бы один элемент, то в данной дочерней таблице таблицы уровня +1 есть хотя бы один элемент,
        выдаем ошибку с сообщением, в какой таблице еще есть данные (можно запросить несколько записей, чтобы была
          информация для вывода пользователю, order by id desc limit <n>)		
*/
----
при добавлении новой записи к таблице типа one не 0-го уровня,
  можно проверять, нет ли уже записи в этой таблицы с нужным parent_id, и если есть, то
    делать не insert(), а update с id этой записи
----
сделать хук onHtmlTableView - он вызывается для каждого столбца каждой записи выводимой в формате таблицы
 для L,D и позволяет изменить выводимый текст со ссылкой перехода на редактирование записи данной таблицы
   (например, для str это может быть '<a href="..../edit_rec/<id>/<id2>">Строка</a>' )
/**
@param string $name - имя поля, для которого необходимо вывести значение
@param &$value - значение этого поля в текущей записи (оно равно $rec[$name])
@param string &$htmlToOutput - значение, которое предполагается вывести (вы можете изменить его)
   в случае, если оно было изменено, выводится измененное значение
@param string &$linkToGo - url, на которую планируется перейти при нажатии на этот html (вы можете изменить его)
   в случае, если оно было изменено, а $htmlToOutput не был изменен, html для вывода переделывается на эту ссылку
*/
public function onHtmlTableView(int $id, array &$rec, array &$columns, string $name, &$value, string &$htmlToOutput, string &$linkToGo)
  
-----
в будущих версиях
  также можно сделать хук onMakeTableView, позволяющий вернуть html для отображения таблицы(начало и конец), шапки таблицы,
  строки(начало и конец),
  ячейки (начало и конец)
таким образом, можно отображать все не в виде стандартной таблицы, а как то по-другому  
----
в будущих версиях
  в случае получения ошибки из за несоответствия метаструктуры (в частности, при получении данных типа 'select'),
   пытаться при возможности определить в каких таблицах и полях заключается ошибка
----
в этой версии : сделать класс вывода шапки  таблицы со списком имен полей с возможностью сортировки при 
  нажатии на имя
  также сделать возможность вывода полей по умолчанию для данного типа таблицы
  
 в контроллере вывода общей таблицы L,D (а потом и во всех общих и для редактирования записей контролллерах):
   сделать получение данных через BasicTableModel->prepareDataForView(int $table_id, array $nesteIds[..., ]) 
      где $table_id - id текущей таблицы, $nestedIds - массив id вложенных в него таблиц, которые будем 
	    также отображать на этой странице (yy_tables->show_with_parent == 1) (сейчас пока что передаем в $nestedIds 
		  пустой массив)
  всегда вызывать родительскую реализацию функции (из BasicTableModel), а то слишком долго отлаживать если напложу версий
  эта функция:
  1) читает данные по всем таблицам из yy_tables в $tablesT[] вида [<id таблицы> => [<массив данных из yy_tables>]]
  2) в случае если каких-то id нет в прочитанном списке, gotoErrorMessage()
  3) читает определения данных столбцов для всех таблиц в $columnsT также  вида [<id таблицы> => [<массив колонок для данной таблицы из yy_columns>]]) - в $columnsT для каждой таблицы должен быть перед загрузкой данных проставлен
    пустой массив <id таблицы> => []
  4) читает данные о выводимых столбцах для всех таблиц вида L,D в массив $tableColumnsT[он тоже с key=id таблицы]	
       если по данным из сессии используются выводимые столбцы по умолчанию, то читает их вместо тех, которые 
	     указаны в БД
  5) если для какой-то из таблиц нет выводимых столбцов, то записывает для этих таблиц в выводимые столбцы (в БД) выводимые столбцы по умолчанию для данных таблиц, затем перечитывает $tableColumnsT (пункт 4, но не в цикле, а 
    только один раз)
  6) возвращает значения $tablesT, $columnsT, $tableColumnsT	
  
in future versions:
  сделать возможность вывода дочерних таблицы на странице родительской
    для views отображения общей информации данного типа сделать под-вью с именем '<$view_name>-inline',
       оно должно отображать непосредственно данные, без заголовка страницы и другой информации.
    Эти вью будут в дальнейшем вызываться для отображения подтаблиц с view_with_parent == 1	   
-----
in futher versions:
  сделать возможность выбора таблиц на которые ссылается поле типа 'select' из всех подтаблиц таблиц типа
    'one' нулевого уровня
------
in futher versions:
  struct-add-table - если 0-вой уровень, при выборе типа 'one' в сохранять предыдущее значение id_size идентификатор
    присваивать id_size = 1 (1 байт)
------
later in futher versions:
  сделать уровни доступа:
  $db::ACCESS_NONE = 0
  $db::ACCESS_READ = 30
  $db::ACCESS_WRITE = 60
  $db::ACCESS_SUPER = 255 (этот уровень доступа может быть только у 'admin')
  
  в программе после старта должен быть доступен $user
   c методами и полями: $user->group
   $user->hasAccess(int $accessLevel, string $tag, int $id)
   в каталоге Models\nesttab может быть создан файл access.php
    с функциями
	makeGroups() - здесь создаются группы методами $ac->makeMainGroup($name, $id, bool $hidden = false)
	 для main group доступен метод $group->addDefaultAccess(array $tags, $accessLevel) - он должен быть
	   вызван для всех основных тэгов
	 $ac->makeGroup($name, $id, $parentGroupName, bool $hidden = false)
	  здесь $id - id вновь создаваемой группы (int)
	  $hidden = false, то не нужно отображать в общем списке доступных для назначения групп
	 где $ac - Access Control Object
	 $group->setAccess(['edit', 'struct', ...], [<table_id>, ...], $accessLevel)
	setUserAccess($userName, $user) {
		switch ($userName) {
		   case 'user1':
		   $user->setAccess(array $tags /*['edit', 'struct', ...]*/, [<table_id>, ...], $accessLevel)
		}
	}
	каждый объект пользователя или группы содержит список $tags[$tag_name][$table_id]
	  каждая main group содержит также список $defaultAccess[$tag_name]
	значениями в обоих этих списках являются (int)$accessLevel
    методом hasAccess() проходится вверх начиная от $user и дальше по всей цепочке групп до главной
      если в списках находится переданный id, то берется его $accessLevel
       если нигде вплоть до main group не найдено, но найдено в $mainGroup->defaultAccess для тэга, то 	  
	   возвращается это значение
	  значение сравнивается с требуемым уровнем доступа, если оно >= чем он, то возвращается true
       если нигде не найдено, возвращается false	  
	специальной функцией создаются predefined group list
	 в нем 
	 'superadmin' - группа c id = 1 из одного пользователя 'admin' ему разрешен доступ ко всему
	 'admins' (id = 2)
	 'moderators' - группа модераторов с id = 3
	 'users' (id = 4) - пользователя относят к этой группе, если он залогинен, но не принадлежит ни к 
	   одной из других групп (в БД), либо он не прошел проверку на принадлежность к другой группе
	 'guests' (id = 5) - все незалогиненные пользователи  
	   и назначаются теми же функциями начальные права на эти группы
-----

i think, in this version:
   при добавлении component к проекту, может быть создано в таблице типа 'one' поле типа 'filedata' (hidden -
    не может быть добавлено через интерфейс nesttab)
	у этого поля поля: ['file' => <путь к файлу конфигурации в котором хранятся данные (он представлен в виде 
	  массива php)>], 'values' => [['<имя переменной из файла>', '<отображаемое имя переменной из файла>'], ...],
	  'addedFiles' => [<пусть к добавленному к проекту файлу>, ...],
	  'comment' => '<комментарий для вывода на форме редактирования, в частности, с инфорацией о том,
	    какие файлы по какому пути добавлены и что в них находится>']
	при редактировании в форме поля 'filedata' могут быть отредактированы только 'values'
     и для обычного пользователя выводятся только 'values' (а для админов также 'comment', 'file')	
----
maybe later or in this version:
  сделать post validators
  \PostValidator::add('<form field name>', '<tags>'); - вызывать в форме
    где tags например 'int,notLessThen(1)'
  при этом к форме добавляются поля вида <input type="hidden" name="$<form_field_name>" value ="int,notLessThen(1)" />	
  также эти пост валидаторы можно использовать в nesttab\tables\yz_xxxx :
     if (\PostValidator::validate('<form field name>', '<tags>')) { /* ошибки валидации не было */ }
---
later:
   сделать возможность задания ненулевых дефолтных значений для полей типа select,date,datetime
----
later:
  создать поле 'data' (наподобие 'datetime'), убрать Null в поле datetime
---

---- задание не id а другого поля для индексирования для поля select не стоит делать (все равно читается вся таблица,
и id это уникальный идентификатор)

----
maybe later in later versions:
  сделать planned jobs
  они должны действовать так:
  1. в nesttab инициируется действие (например, удалить столбец таблицы)
  2. действие не выполняется, а добавляется в plannedjobs[$user], и происходит переход на страницу с 
   сообщением что запланирована работа
  3. администратор запускает удаленный терминал к сайту и через php artisan запускает на выполнение 
    данное действие (здесь преимущество в том, что время выполнения скрипта не ограничено)
---
search - в индекс могут сохраняться данные только этой таблицы (в след. версии определенного, плюс следующего уровня таблиц)
yy_search - url, url_parts(адрес, где находится в url тот или иной элемент), txt, txt_parts
----
if id == 0 && !hasErr() { setDefaults() }
---
!!! таблицы типа "one" могут быть на любом уровне
         для таблицы типа one можно устанавливать yy_tables->make_with_parents (установленный флаг значит,
		  что этот элемент нужно создавать при создании родительского (на один уровень вниз))
!!!   для ссылки на предыдущие таблицы добавляются поля id1, id2, ... (сколько нужно)
   запретить задание пользовательских полей вида 'id<N>'
   создать ArrayHelper::collectNs(string $name, array $arrFrom, array &$arrTo):int (сколько номеров заколлекчено) $arr - (key - $name.<N>, value - $arrFrom[$name.<N>])
-------
в boot() провайдера:
что то типа 
//$this->loadTranslationsFrom(__DIR__.'/../resources/lang', 'name');
$this->publishes([
            __DIR__.'/../resources/lang' => resource_path('lang/vendor/name'),
        ], 'lang');
!!! проверить, как будет подключаться пагинация русифицированная
------
!!! (не так, сделать новый тип поля ref, который будет добавлять запись в yy_ref) добавить поле _srv_ для поля типа string - преобразование строки в вид для url
      к полю - признак "русское/английское"
	в field.save() - добавить возможность добавлять-удалять дополнительное поле
      ошибки бд как обрабатывать-различать?
	  также проверку на то, что текущее поле включено в индекс mysql
        такую же проверку в field.delete()	  
----
- (не знаю, стоит ли) в следующих версиях
    сделать "Секции" - разбиение одной записи на несколько разделов (но все хранится в одной записи)
----
в  следующих версиях
    сделать несколько url rewrite (как в битрикс) для одной записи, при этом если хотя бы одно строковое значение
	 пустое, то не записывать в поиск этот Url rewrite
----
+ сделать поле db типа link (ссылка на другую таблицу) (тип поля int)
+   это поле ссылается на поле <field> типа string другой таблицы
+   при редактировании (в этой версии) в тэг <select> заносится набор (id, <field>) из всех записей этой таблицы
!!! нужно написать в хелпе (и инлайн хелпе) что при большом количестве записей в таблице желательно проиндексировать
  ее по полю <parent_id>,<field> и не желательно большое количество данных в этой таблице (больше 1000 записей)
----
в следующих версиях:
 сделать js компоненты NesttabDbStringList, NesttabDbComboBox, NesttabDbSearchStringList, NesttabDbSearchComboBox
 (на основе div and hidden form field)
 обращается за данными через ajax
   там идет запрос к бд select id, name from table where (name = '$name1' and id > $id1) or (name > '$name1')
		limit 0, $recsNeeded + 1
	где $recsNeeded - количество нужных записей бд	
     где $name1, $id1 = строковое поле текущей записи и идентификатор текущей записи
 также может быть локальный запрос данных
 запрашиваются данные с параметрами (isBefore, isAfter /*(нужно ли возвращать массив до и после тек. записи) */)
 данные возвращаются в виде массива:
  {
	isStart: boolean, // достигнуто начало набора данных
	isEnd: boolean, // достигнут конец набора данных
	beforeList: { // список данных перед текущей (или найденной search) записью
		{id: <id>, text: '<text>'},
		...
	},
	afterList: { // список данных после текущей (или найденной search) записью
		{id: <id>, text: '<text>'},
		...
	}
  }  
---
!!! удаление записи таблицы возможно только если ниже ее заполенено не более одного уровня данных
  (предусмотреть в том числе для каталогов дерева)
-----
вложенность таблиц - до бесконечности
 удалять запись можно только когда ниже ее не больше одного уровня данных (удаляем вместе с этим уровнем)
 - отображаем в хлебных крошках текущий уровень, и 2 предыдущих (дерево считается за один уровень)
------
к таблицам добавить поле признак "Является компонентом" (component_id<>0)
 для компонентов дополнительные поля - текстовое значение из config.php компонента, целое значение из config.php 
   компонента (данные читаются из config.php выгруженного в ларавел компонента)
 каталоги которые могут добавится: laravel/views/news.detail
   laravel/Models/news.detail (тут config.php)
 также для таблицы компонента добавляется поле "выбор компонента" news_detail_sys (имя таблицы) (пишется в config.php)  
 - зарезервировать имена таблиц заканчивающихся на _sys для компонентов
--- 
сделать тип таблицы component 
 - это тот же тип list, но есть поле component_id в которое данные берутся из таблицы yy_components (там список
   инсталлированных компонентов) и поле component_name(string, for example paginator4 - выбирается свободное имя
     файла для него) - при добавлении также выгружать компонент в ларавел
добавить поле component_id в yy_tables (если не является компонентом, то 0)	 
 в yy_components поле edit_object (адрес объекта для редактирования)
- при редактировании таблицы если есть Models/Nesttab/<имя таблицы>.php, то обрабатываются сначала хуки из него
   потом если это компонента, то хуки из компоненты (edit_object)
   - в хуке при вызове передается параметр $chain_go_next (обрабатывать ли хуки компонента для имени таблицы,
   для хуков компонента просто передается переменная и не меняется)
----
- в следующей версии nesttab:
 сделать таблицы типа user (key parent_id, user_id) - отображается как one для текущего пользователя
   таблица как тип ord
- при редактировании таблиц типа one и user добавлять insert into values(0) перед отображением записи
-----
3 типа аддонов:
Html
Field
Component (!!! аддоны типа компонент не делаю, по крайней мере пока не сделал интернет магазин)

в корневом каталоге laravel - каталог addons
 в нем каталоги аддонов вида <vendor>/<addon>
 в нем файл config.ini вида
[Html]
<addon>
...
[Html_current]
<addon2>
[Field]
<addon>
...
[Component]
<addon>
...

где <addon> - это адрес каталога аддонов типа <vendor>/<addon><пробел><название аддона> 
 <addon2> - это адрес каталога аддонов типа <vendor>/<addon> 

предусмотреть функцию readAddonsConfig($filename, $toSection) 
  // $toSection - вплоть до какой секции читать файл
 файл читаем построчно
----- не поставить html editor wymeditor (xhtml dual license mit) -  конфликт с текущей версией jquery,
- не markitup (mit license, но не wisywig), не nicedit (mit license, но давно сделан - в 2008 году - конфликт с jquery) 
- то есть оставляю ckeditor4, но делаю его отдельно (он по copyleft лицензии)
-------------
- посмотреть, как будет работать сохранение записи при key violation in db


- BasicModel->saveStep2() - чтобы работало если не хватает места на диске

+ app.php поставил timezone Europe/Moscow
     - time() выдает время на 3 часа раньше текущего 
   ---- TOkenUploadModel->deleteOldTokens() - timeSpan почему-то выдает -4 часа вместо -1

- можно отслеживать violation ключей бд при добавлении-изменении записей
 тогда выдается сообщение mysql:
	#1062 - Duplicate entry '1-0' for key 'id2'
 (hook onDataModifyError)
 
- при добавлении-обновлении записей в несттаб - сначала записывать все данные без данных image,file,
    затем, если не было ошибок - данные image,file
 
- в методе удаления директорий - проверять на подстроку '..'

- сделать createDir with chunks 

+++++ - js __lang('Close') (сделать языковую трансляцию для js)

!!! в поле File запретить загрузку файлов с любым расширением - всегда должен быть список допустимых расширений
   (чтобы не загружали например файлы типа "php" с тем чтобы можно было их удаленно запустить на сервере)

- в следующих версиях: сделать галочку для таблиц типа "Список" и "Произвольные данные", позволяющую отображать их
   при редактировании на одном уровне с родительской записью

- в следующей версии : ckeditor - image to the right (кнопка "изображение" справа от редактора для работы с файлами изображений)

- !!! (в этой версии) Сделать регистрацию зарегистрированных пользователей 

сделать удаление поля типа File с удалением соответствующих файлов

!!! сделать cache::lock на добавление - редактирование полей таблиц

!!! при редактировании/добавлении полей в таблицах типа 'one' не вводить значение по умолчанию

!!! при удалении таблицы удалять сначала таблицу физически, и если ошибка не "таблица не существует",
  то не удалять из метаданных и выдавать ошибку

!!! сделать возможность удаления таблиц

!!! удаление из таблиц где верхний уровень - дерево:
  select where topid = ? left join on a.id = b.topid (3 Раза) limit 0, 40 
    (это записываем в массив, если у элемента нет подэлементов в дереве, то тоже можно дочерние в других таблицах
	   удалять)
 если дерево не верхний уровень, то просто select order by id desc where parent_id = ?	   

загрузка изображений - счетчик номеров директорий сделать в виде текстового файла
!!!!!! в таблицы верхнего уровня не добавлять поле parent_id и другие указывающие на родительскую таблицу

сделать объект - обработчик index.php в public каталоге, который смотрит файл .url_rewrite и при соответствии 
 записи типа preg_match передает в путь, указанный на следующей строке параметры $_GET['n_values'], равные
 результату preg_match
  - также в файле .url_rewrite могут быть комментарии, начинающиеся на #
  - записи в .url_rewrite разделяются пустой строкой

-----
можно использовать Laravel-Lang/lang
 пакет для языковой локали русской и других
 
подключить Html редактор - вроде Trix с изображениями редактор

---
в новых версиях (после 1-й):


1) полнотекстовый поиск по БД
- для полей самой таблицы указывать, включается ли это поле в поиск
- указывать строку с адресом url, на основе имен полей, с возможностью указания имени таблицы для
  родительских полей (например, "item/{yz_cat.txt_res_trans}/{txt2_res_trans}"
    (где txt2_res_trans - это поле транслита для поля txt таблицы yz_cat, таблица yz_cat является родительской
	  для текущей таблицы, txt2_res_trans - поле транслита для поля txt2 текущей таблицы)
2) предусмотреть возможность формировать вручную поле полнотекстового поиска для указанных таблиц
2.1) структура для всех формирующихся вручную данных полнотекстового поиска задается в одной единственной callback-
  функции getFullTextSearchStructure() объекта UserFullTextSearch в виде набора команд:
   $this->addInfo(string $tableName, array $childTablesNames, string $buildMethod)
    где $tableName - имя таблицы, которая является основной для индексации этого набора таблиц
	$childTablesNames - array of string - имена дочерних таблиц любого уровня для основной, данные из которых тоже
	  будут сохранятся в поле полнотекстового поиска
	$buildMethod - имя метода объекта UserFullTextSearch, который будет формировать значение поля полнотекстового
    	поиска
	  формат метода: $this->{$buildMethod}(array $thisRecord):array
	   @param array $thisRecord - содержимое записи в $tableName, для которой генерируется значение полнотекстового
	     поиска
	   @return [string $url, string $ret_value] - [url, сгенерированное значение поля полнотекстового поиска]
	   
2.2) пример реализации данной технологии:

class UserFullTextSearch {
	public function getFullTextSearchStructure() {
		$this->addInfo('yz_cat3', ['yz_list4'], 'buildCat3');
		//$this->addInfo('yz_list5', ['yz_list48'], 'buildList5');
		//$this->addInfo('yz_cat8', ['yz_ord3', 'yz_list2'], 'buildCat8');
	}
	public function buildCat3(array $thisRecord):array {
	    /** пусть у yz_cat3 ключ id
		      $tableName - это yz_cat3
		      поле yz_cat3.txt_res_trans - транслит поля txt
			  также включаются в поиск поля yz_cat3.description и yz_cat3.txt
			  
			  пусть таблица yz_list4 - следующая по вложенности после yz_cat3 (вложенная в нее) и пусть нам нужны поля
			  yz_list4.item и yz_list4.name
		*/	  
		$s = $thisRecord['txt'] . ' ' . $thisRecord['description'];
		$results = DB::select("select item, name from yz_list4 where parent_id = ? order by ordr", [$thisRecord['id]]);
		foreach ($results as $result) {
			$s .= ' ' . $result->item . ' ' . $result->name;
		}
		$url = 'item/' . $thisRecord['txt_res_trans'];
		return [$url, $s];
	}
}

3) также предусмотреть artisan job для всех таблиц всей БД и с параметром --table=yz_cat4 (только для данной таблицы)
    

6) в следующих версиях несттаба: для индексации (полнотекстового поиска) по записям - добавить поле типа "address" : 
это 2 поля в таблице, в первом содержится адрес записи на итоговом сайте, в виде "{one2.name}/{name}" например.
 в случае, если такое поле или такая таблица в очереди родительских таблиц не найдена, при сохранении или удалении
  записи запись не сохраняется и выводится ошибка
 2-е поле: так же как и в первом, в нем могут использоваться имена полей таблиц : "catalog?id={id}&parent_id={ord4.id}"
  (путь относительно корня сайта)
 - полей такого типа (address) для каждой записи может быть несколько, например, для нескольких языковых версий сайта
---
+сделано (в основном для Jquery в models/nesttab/tables)
+     addBlockOnce($blockName, $tagName, $value) - где $blockName может быть равно 'jquery'
+	   для уникального $tagName $value добавляется только один раз
-----
block 'jquery_before'
-----
сделать компоненты search, news, catalogue  
---
todo in next versions:
  сделать функцию получения пустой записи для указанной таблицы из системы nesttab 
   (генерируется на основе значений по умолчанию, в него передается указатель на pdo handle, делается в отдельном от laravel системы модуле)
----
когда нибудь в следующих версиях:
 сделать проверки при работе с произвольными именами БД на правильное имя таблиц
  mustBeDBSafeName(string $tableName) - сделать функцию для работы с произвольным именем бд

---
на unix сервере
  проверить, как работает ajax с новым вызовом страниц (либо с редиректом) (для длительных операций)